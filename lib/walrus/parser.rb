# Copyright 2007 Wincent Colaiuta
# $Id$

require 'walrus/token'

module Walrus
  class Parser
  
    attr_reader :tree
  
    # Takes an array of input Tokens (generated by the lexer) and attempts to generate a valid tree structure based on those tokens.
    def initialize(tokens)
      raise ArgumentError.new('tokens is nil') unless tokens
      
      # will actually be modifying the tokens so do a "deeper" copy
      @tokens = tokens.collect { |token| token.clone }
      self.parse
      
    end
  
    def parse
      # May need to make this method recursable as well
    
      # reset state
      @tree           = []
      @current_index  = 0
    
      # parse
      while token = self.next_token
      
        if token.comment?
          self.parse_comment(token)
        elsif token.text?
          self.parse_text(token)
        elsif token.directive?
          self.parse_directive(token)
        elsif token.token?
          self.parse_eol(token)
        elsif token.silent_token?
          self.parse_silent_eol(token)
        elsif token.placeholder?
          self.parse_placeholder(token)
        end
      
      end
    
      @tree
    
    end
  
    # Parse the Comment token at the current index.
    def parse_comment(token) 
      raise ArgumentError.new('token not a Comment') if not token.comment?
      @tree.push(token.clone)   # Comments go through unchanged
    end
  
    # Parse the Text token at the current index.
    def parse_text(token)
      raise ArgumentError.new('token not Text') if not token.text?
      @tree.push(token.clone)  # Text instances also go through unchanged
    end
  
    # Parse the Directive token at the current index.
    def parse_directive(token)
      raise ArgumentError.new('token not Directive') if not token.directive?
      directive = token.directive_string
      if directive == 'import'
        self.parse_import(token)
      elsif directive == 'extends'
        self.parse_extends(token)
      elsif directive == 'def'
        self.parse_def(token)
      elsif directive == 'block'
        self.parse_block(token)
      elsif directive == 'end'
        self.parse_end(token)
      else
        # etc
      end
    
    end
  
    # Each template may have only one #import or #extends directive
    # the second such directive found will raise an exception
    # "multiple inheritance is not supported"
    # if no #import or #extends is found, we implicitly inherit from the "Document" class
    def parse_import(token)
      parameter = token.parameter_string
      raise ParseError.new("missing parameter string", token) unless parameter
    
    
    end
  
    def parse_extends(token)
    end
  
    def parse_def(token)
    end
  
    def parse_block(token)
    end
  
    def parse_end(token)
    end
  
    # Parse the EOL token at the current index.
    def parse_eol(token)
      raise ArgumentError.new("Token is not an EOL") if not token.token?
      @tree.push(token.clone)  # EOL instances also go through unchanged
    end
  
    # Parse the SilentEOL token at the current index.
    def parse_silent_eol(token)
      raise ArgumentError.new("Token is not a SilentEOL") if not token.silent_token?
      @tree.push(token.clone)
    end
  
    # Parse the Placeholder token at the specified index.
    def parse_placeholder(token)
      raise ArgumentError.new("Token is not a Placeholder") if not token.placeholder?
      raise "Not implemented"
    end
  
    # Returns the next available token, incrementing the current_index property. Returns nil if no token available.
    def next_token
      return nil if @current_index >= @tokens.length
      token = @tokens[@current_index]
      @current_index = @current_index + 1
      token
    end
  
  end # class Parser
end # module Walrus

module Walrus
  
  class PParser
    
    def initialize
      grammar = Grammar.new('WalrusGrammar') do
        
        # for this grammar to work need to be able to specify default behaviour for handling inter-token whitespace
        # that way we can avoid the need to explicitly put "ws.optional" between elements
        
        # would be nice if we could tell productions to "flatten" their content into a single string
        # although the string literal content example shows that this might not be necessary if you can produce a single regexp match
        
        # would be nice if you could specify Node superclasses as well (for example, have a node subclass inherit from another node subclass)
        # example, single and double quoted strings
        
        starting_symbol :template
        
        rule            :ws,                            /\s+/         # whitespace
        rule            :nl,                            /\r\n|\r|\n/  # newlines
        
        rule            :template,                      :template_element.zero_or_more        # up to end-of-file
        rule            :template_element,              :directive | :placeholder | :comment | :raw_text | :escape_sequence
        
        rule            :raw_text,                      /[^#$\\]+/
        
        rule            :string_literal,                :single_quoted_string_literal | :doble_quoted_string_literal
        rule            :single_quoted_string_literal,  "'".skip & :single_quoted_string_content.optional & "'".skip
        rule            :single_quoted_string_content,  /(\\(?!').|\\'|[^'\\]+)+/
        rule            :double_quoted_string_literal,  '"'.skip & :double_quoted_string_content.optional & '"'.skip
        rule            :double_quoted_string_content,  /(\\(?!").|\\"|[^"\\]+)+/
        
        rule            :identifier,                    /[a-zA-Z_][a-zA-Z0-9_]*/
        
        rule            :ruby_expression,               # string literals, numbers, arrays, method calls, etc (basic Ruby subset)
        
        rule            :escape_sequence,               :escape_marker & :escape_character
        rule            :escape_marker,                 '\\'
        rule            :escape_character,              /#\\\$/
        
        rule            :directive,                     '#'.skip & :directive_name & :directive_parameters.optional
        rule            :directive_name,                /[a-zA-Z]+/
        rule            :directive_parameters,          '('.skip & (:directive_parameter >> (',''#'.skip & :directive_parameter).zero_or_more ).optional & ')'.skip
        rule            :directive_parameter,           :placeholder | :ruby_expression
        
        rule            :placeholder,                   '$'.skip & :placeholder_name & :placeholder_parameters.optional
        rule            :placeholder_name,              :identifier
        rule            :placeholder_parameters,        '('.skip & (:placeholder_parameter >> (',' & :placeholder_parameter).zero_or_more).optional & ')'.skip
        rule            :placeholder_parameter,         :placeholder | :ruby_expression
        
        rule            :comment,                       '##'.skip & :comment_text.optional
        rule            :comment_text,                  /.+$/
        
        # which syntax looks better? this? (all on one line)
        rule            :comment,                       :comment_marker & :comment_text.optional ^ (:Comment, :skip, :comment_text)
        
        # or this? (separate line using "production" method)
        rule            :comment,                       :comment_marker & :comment_text.optional
        production      :comment, :Comment,             :skip, :comment_text
        
        # or this? (first option split across two lines)
        rule            :comment,                       :comment_marker & :comment_text.optional ^ 
                        (:Comment,                      :skip,            :comment_text)
        
        # or this? (separate "production" method, but inferring Node class); i think this is the neatest/nicest
        # but it requires a different approach, instead of wrapping before storing the rule, we wrap at runtime in the parse method
        rule            :comment,                       :comment_marker & :comment_text.optional
        production      :comment,                       :skip, :comment_text
        
      end
    end
    
  end # class PParser
  
end # module Walrus