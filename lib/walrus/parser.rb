# Copyright 2007 Wincent Colaiuta
# $Id$

require 'walrus/token'

module Walrus
  class Parser
  
    attr_reader :tree
  
    # Takes an array of input Tokens (generated by the lexer) and attempts to generate a valid tree structure based on those tokens.
    def initialize(tokens)
      raise ArgumentError.new('tokens is nil') unless tokens
      
      # will actually be modifying the tokens so do a "deeper" copy
      @tokens = tokens.collect { |token| token.clone }
      self.parse
      
    end
  
    def parse
      # May need to make this method recursable as well
    
      # reset state
      @tree           = []
      @current_index  = 0
    
      # parse
      while token = self.next_token
      
        if token.comment?
          self.parse_comment(token)
        elsif token.text?
          self.parse_text(token)
        elsif token.directive?
          self.parse_directive(token)
        elsif token.token?
          self.parse_eol(token)
        elsif token.silent_token?
          self.parse_silent_eol(token)
        elsif token.placeholder?
          self.parse_placeholder(token)
        end
      
      end
    
      @tree
    
    end
  
    # Parse the Comment token at the current index.
    def parse_comment(token) 
      raise ArgumentError.new('token not a Comment') if not token.comment?
      @tree.push(token.clone)   # Comments go through unchanged
    end
  
    # Parse the Text token at the current index.
    def parse_text(token)
      raise ArgumentError.new('token not Text') if not token.text?
      @tree.push(token.clone)  # Text instances also go through unchanged
    end
  
    # Parse the Directive token at the current index.
    def parse_directive(token)
      raise ArgumentError.new('token not Directive') if not token.directive?
      directive = token.directive_string
      if directive == 'import'
        self.parse_import(token)
      elsif directive == 'extends'
        self.parse_extends(token)
      elsif directive == 'def'
        self.parse_def(token)
      elsif directive == 'block'
        self.parse_block(token)
      elsif directive == 'end'
        self.parse_end(token)
      else
        # etc
      end
    
    end
  
    # Each template may have only one #import or #extends directive
    # the second such directive found will raise an exception
    # "multiple inheritance is not supported"
    # if no #import or #extends is found, we implicitly inherit from the "Document" class
    def parse_import(token)
      parameter = token.parameter_string
      raise ParseError.new("missing parameter string", token) unless parameter
    
    
    end
  
    def parse_extends(token)
    end
  
    def parse_def(token)
    end
  
    def parse_block(token)
    end
  
    def parse_end(token)
    end
  
    # Parse the EOL token at the current index.
    def parse_eol(token)
      raise ArgumentError.new("Token is not an EOL") if not token.token?
      @tree.push(token.clone)  # EOL instances also go through unchanged
    end
  
    # Parse the SilentEOL token at the current index.
    def parse_silent_eol(token)
      raise ArgumentError.new("Token is not a SilentEOL") if not token.silent_token?
      @tree.push(token.clone)
    end
  
    # Parse the Placeholder token at the specified index.
    def parse_placeholder(token)
      raise ArgumentError.new("Token is not a Placeholder") if not token.placeholder?
      raise "Not implemented"
    end
  
    # Returns the next available token, incrementing the current_index property. Returns nil if no token available.
    def next_token
      return nil if @current_index >= @tokens.length
      token = @tokens[@current_index]
      @current_index = @current_index + 1
      token
    end
  
  end # class Parser
end # module Walrus

module Walrus
  
  class PParser
    
    def initialize
      grammar = Grammar.new('WalrusGrammar') do
        
        # for this grammar to work need to be able to specify default behaviour for handling inter-token whitespace
        # that way we can avoid the need to explicitly put "ws.optional" between elements
        
        # would be nice if we could tell productions to "flatten" their content into a single string
        # although the string literal content example shows that this might not be necessary if you can produce a single regexp match
        
        starting_symbol :template
        
        # one argument: this is the default "skip" parslet
        # it is passed inside the "options" hash when invoking the "parse" methods
        # basically, any parser which fails will retry after giving this intertoken parslet a bash
        skipping        :whitespace_or_newlines
        
        # two arguments: this specifies the inter-token "skip" parslet for a given rule
        #skip            :directive, :whitespace
        
        rule            :whitespace,                    /\s+/
        rule            :newlines,                      /\r\n|\r|\n/
        rule            :whitespace_or_newlines,        :whitespace | :newlines
        rule            :end_of_input,                  /\z/
        
        rule            :template,                      :template_element.zero_or_more & :end_of_input.and?
        rule            :template_element,              :comment | :directive | :placeholder | :raw_text | :escape_sequence
        
        rule            :raw_text,                      /[^#$\\]+/
        
        rule            :string_literal,                :single_quoted_string_literal | :doble_quoted_string_literal
        node            :string_literal
        
        rule            :single_quoted_string_literal,  "'".skip & :single_quoted_string_content.optional & "'".skip
        production      :single_quoted_string_literal.build(:string_literal)
        rule            :single_quoted_string_content,  /(\\(?!').|\\'|[^'\\]+)+/
        rule            :double_quoted_string_literal,  '"'.skip & :double_quoted_string_content.optional & '"'.skip
        production      :double_quoted_string_literal.build(:string_literal)
        rule            :double_quoted_string_content,  /(\\(?!").|\\"|[^"\\]+)+/
        
        rule            :identifier,                    /[a-zA-Z_][a-zA-Z0-9_]*/
        
        rule            :ruby_expression,               # string literals, numbers, arrays, method calls, etc (basic Ruby subset)
        
        rule            :escape_sequence,               :escape_marker & :escape_character
        rule            :escape_marker,                 '\\'
        rule            :escape_character,              /#\\\$/
        
        rule            :directive,                     '#'.skip & :directive_name & :directive_parameters.optional
        rule            :directive_name,                /[a-zA-Z]+/
        rule            :directive_parameters,          '('.skip & (:directive_parameter >> (',''#'.skip & :directive_parameter).zero_or_more ).optional & ')'.skip
        rule            :directive_parameter,           :placeholder | :ruby_expression
        
        rule            :placeholder,                   '$'.skip & :placeholder_name & :placeholder_parameters.optional
        rule            :placeholder_name,              :identifier
        rule            :placeholder_parameters,        '('.skip & (:placeholder_parameter >> (',' & :placeholder_parameter).zero_or_more).optional & ')'.skip
        rule            :placeholder_parameter,         :placeholder | :ruby_expression
        
        rule            :comment,                       '##'.skip & /.*$/
        production      :comment.build(:node)
        
        
      end
    end
    
  end # class PParser
  
end # module Walrus